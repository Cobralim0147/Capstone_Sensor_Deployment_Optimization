________________________________________________________________________
Part 1: Deployment

1: Initialize population with one heuristic solution and the rest random
2: Set archive to empty
3: Set generation to 0

4: while not found 100% coverage AND generation < Max_Generations
    // Fitness Assignment
    5: Calculate strength for each individual in population and archive
    6: Calculate raw fitness for each individual
    7: Calculate density for each individual
    8: Set fitness = raw fitness + density

    // Environmental Selection
    9:  Select non-dominated individuals to archive
    10: If archive size < required, add best dominated individuals
    11: If archive size > required, remove crowded individuals based on density

    // Check for full coverage solution
    12: If any individual in archive has 100% coverage
        13: Set found = true
        14: break

    // Create new population
    15: Set new population to empty
    16: while new population size < population size
        17: Select two parents using tournament selection
        18: Create child using crossover
        19: Apply smart mutation to child
        20: Evaluate objectives for child
        21: Add child to new population
    22: end while

    23: Replace old population with new population
    24: Increment generation
25: end while

26: If found 100% coverage, return solutions with 100% coverage
27: Else return final archive
________________________________________________________________________

Part 2: Clustering 

1: Determine initial number of clusters (k)
2: While k â‰¤ number of sensors
    3: For attempt from 1 to Max_Attempts
        4: Initialize cluster heads using Coverage-Based method
        5: For iteration from 1 to Max_Iterations
            // Assignment step
            6: Assign each head to its own cluster
            7: For each unassigned sensor
                8: For each cluster sorted by distance to the head
                    9: If within communication range and cluster not full
                        10: Assign sensor to cluster
                        11: Break
                12: End for
            13: End for
            
            // Update step
            14: For each cluster
                15: Compute centroid of members
                16: Select closest actual sensor to centroid as new head
            17: End for
            18: If cluster heads did not change, break (converged)
        19: End for
        
        // Solution Found
        20: If valid clustering with zero orphans found
            21: Save best assignments and cluster heads
            22: Break from attempts loop
        23: Else, track lowest orphan count
    24: End for
    
    25: If successful clustering found
        26: Return final assignments, heads, and stats
        27: Else
        28: Increase k by 1 and repeat
29: End while

30: If all k values exhausted and no solution found
    31: Return clustering failed
    
    
________________________________________________________________________  
Part 3: Data Collection

1: Initialize parameters and grid
2: Map base station and cluster heads to nearest valid grid points
3: For each cluster head, create collection zones within communication range
    4: Calculate distance matrix using A* pathfinding between nodes
    
    // Begin Ant Colony Optimization loop
    5: for iteration from 1 to Max_Iterations
        // Each ant builds a tour
        6: for each ant in Ants
        7: Start at base station
        8: while there are unvisited cluster heads
            9: Calculate probability to move to each unvisited node
            10: Select next node based on probability
                11: Add node to path and update total distance
        12: end while
        13: Return to base station
        14: Update local pheromones on the path
        15: if current path is shorter than best path
            16: Update best path and best distance
        17: end if
    18: end for
    
    // Global pheromone update
    19: Reduce pheromone values globally
    20: Reinforce pheromone on the best path
    
    // Save current best distance for convergence tracking
    21: Record best distance in convergence history
    22: if iteration is multiple of 20
        23: Print progress
    24: end if
25: end for

26: Return best path, best distance, and convergence history
________________________________________________________________________    
Part 4: Simulation 


1: Load configuration parameters

// STEP 1: ENVIRONMENT SETUP
2: Generate virtual field environment (shape, size, beds, vegetables)
3: Initialize optimization problem with field and vegetable positions

// STEP 2: SENSOR PLACEMENT (SPEA2)
4: Run SPEA2 algorithm to get Pareto optimal sensor placement solutions
5: Analyze Pareto front and select the best coverage solution
6: Visualize selected sensor placement solution

// STEP 3: CLUSTERING (K-MEANS)
7: Initialize K-Means clustering system
8: Perform clustering on deployed sensors to get cluster assignments and heads
9: Visualize clustering results

// STEP 4: PATH OPTIMIZATION (ACO)
10: Initialize Ant Colony Optimizer with cluster heads and field info
11: Run ACO to find optimal path between cluster heads with obstacle avoidance
12: Analyze path efficiency (distance, waypoints)
13: Visualize rover path with detours and clusters

// STEP 5: SUMMARY
14: Print deployment metrics: sensor count, coverage, connectivity, path length
15: End
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    